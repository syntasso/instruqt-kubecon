---
slug: generate-application-scaffolding
id: okgzfoly5zg5
type: challenge
title: generate-application-scaffolding
teaser: Scaffold a Golang application that can be deployed to Kubernetes as an operator
notes:
- type: text
  contents: |-
    Now that you are comfortable in the environment,
    it is time to get started with `kubebuilder`.

    In this section you will:
    * Initialize Kubebuilder
    * Run the generated controller application locally
tabs:
- title: K8s Shell
  type: terminal
  hostname: kubernetes-vm
  workdir: /root/demo
- title: Code editor
  type: service
  hostname: kubernetes-vm
  path: /
  port: 8443
difficulty: basic
timelimit: 600
---

🚀 Let's start
==============

<> I think this part misses out on fact its also a CRD (An operator thats just a deployment might be a controller? :hides:), or maybe just don't call it a deployment here and go into specifics later?
<> I think its to automate <anything> rather than an application in particular
A Kubernetes operator is a deployment that extends the functionality of the Kubernetes API to automate the creation, configuration, and management of anything.

While this can be generated by hand, there is a tool called `kubebuilder` that can generate scaffolding to get you started quickly.

[Kubebuilder](https://github.com/kubernetes-sigs/kubebuilder) has already been installed on this computer.

Get started by initializing a Kubebuilder application in your `K8s Shell` tab:

```
kubebuilder init \
  --plugins=go/v4-alpha \
  --repo my.domain
```

A number of files have been created to help you get started quickly. While these are exciting to explore more deeply, try to delay this curiosity for now as the rest of this track will jump into key getting started files.

When you are ready, click the next header to first understand the tools provided to build, test, and deploy this code base.


♲ Understanding developer lifecycle tasks
==============

Kubebuilder uses a [Makefile](https://www.gnu.org/software/make/manual/html_node/Introduction.html) as home for all useful commands.

In Make, commands are called "targets". It is good practice to design these targets to be consistent across local, remote, and Continuous Integration (CI) environments which allows for more debuggability and maintainability.

To see available targets, run in the `K8s Shell`:

```
make help
```

Within this help output, take a look for the descriptions of the four main targets you will use today:
* `run`
* `docker-build`
* `install`
* `deploy`

Continue to the next header to already put one of these to use.


👩🏾‍💻 Running your Application
==============

While this is generic scaffolding, it does start with a valid and usable Golang application.

To run this Golang application locally, go to the `K8s Shell` tab and enter:

```
make run
```

This command may take a few minutes, so while it is working, navigate to `main.go` in the root "demo" directory of your `Code editor` tab. In this file, look at line 64 to see where the controller application is created.

> 💡 If you want to navigate to a specific place quickly in the code editor, you can type `ctrl+p` (`cmd+p` on macs) and put the file name there. You can even add the line number after a colon (e.g. `main.go:64`).

In the list of options passed to this `NewManager` function, you will see configuration for both a metrics and health probe endpoint.

Return to the `K8s Shell` tab and view the progress of the run command.

You should see a few commands running including prerequisites like `test` and `controller-gen` commands, and then you should see the following four log lines:

```
INFO	controller-runtime.metrics	Metrics server is starting to listen	{"addr": ":8080"}
INFO	setup	starting manager
INFO	Starting server	{"kind": "health probe", "addr": "[::]:8081"}
INFO  Starting server	{"path": "/metrics", "kind": "metrics", "addr": "[::]:8080"}
```

While minimal now, this is your operator and will be extended to include business logic associated with your custom application.


💡 Extra bonus: Understand make target prerequisites
==============

Before the server logs you will have seen other output. This was generated by the prerequisite targets for the `run` target.

The `run` target is on `Makefile:64` in the root of your `Code editor`. Here you will see the target defined as:

```
run: manifests generate fmt vet ## Run a controller from your host.
  go run ./main.go
```

In Makefiles, any names listed after a target is defined are other targets that will be run as prerequisites. In this case, all four of the prerequisites are both other targets defined in this same Makefile. To be more specific, `manifests` and `generate` both run Kubebuilder `controller-gen` commands to generate some Golang code which is then formated and validated by `fmt` and `vet` before being executed by the intended `run` target.


📕 Summary
==============

While there are a few options for getting started quickly with developing controllers and operators for Kubernetes, Kubebuilder is a great choice due to its support while also providing enough flexibility to create what you need.

You may have noticed that Kubebuilder always uses the term "controller". Don't let this get too confusing, despite you being in a track about building an operator.

Both controllers and operators are at their core an application running in Kubernetes that responds to changes in certain resources. The term operator is just used to clarify a specific type of controller that manages operational concerns for one specific appplication.

Since you will need an application for your core logic, Kubebuilder quickly provides an opinionated way to build, test and deploy a fit for purpose Golang application.
