---
slug: generate-application-scaffolding
id: okgzfoly5zg5
type: challenge
title: Generate application scaffolding
teaser: At its core, an operator is an application that runs in Kubernetes. In this
  challenge you will generate scaffolding for this application to get started quickly.
notes:
- type: text
  contents: |-
    Now that you are comfortable in the environment,
    it is time to get started with `kubebuilder`.

    **In this challenge you will:**
    * Initialize Kubebuilder
    * Run the generated controller application locally
tabs:
- title: K8s Shell
  type: terminal
  hostname: kubernetes-vm
  workdir: /root/demo
- title: Code editor
  type: service
  hostname: kubernetes-vm
  path: /
  port: 8443
difficulty: basic
timelimit: 300
---

ðŸš€ Get started
==============

A Kubernetes operator is an application that extends the functionality of the Kubernetes API to automate resource creation, configuration, and management.

Operators are different from traditional web apps because rather than an HTTP or GRPC request, operators listen to changes of a specified Kubernetes resource.

Today you will create both the operator application and a custom resource type for it to react to when it changes.

ðŸ— Using the right tools
==============

While this can be generated by hand, there is a tool called `kubebuilder` that can generate scaffolding to get you started quickly.

[Kubebuilder](https://github.com/kubernetes-sigs/kubebuilder) has already been installed on this computer.

Get started by initializing a Kubebuilder application in your `K8s Shell` tab:

```
kubebuilder init \
  --plugins=go/v4-alpha \
  --repo my.domain
```

This command has generated a number of files that you can see in the `Code editor` tab that will help you get started quickly. While these are exciting to explore more deeply, try to delay this curiosity for now as the rest of this track will jump into key getting started files.

â™² Understanding developer lifecycle tasks
==============

Kubebuilder uses a [Makefile](https://www.gnu.org/software/make/manual/html_node/Introduction.html) as home for all useful commands.

In Make, commands are called "targets", and it is good practice to design these targets to be consistent across local, remote, and Continuous Integration (CI) environments. This consistently enables better debuggability and maintainability.

To see available targets, run in the `K8s Shell`:

```
make help
```

Within this help output, take a look for the descriptions of the four targets you will use most today:
* `install`
* `run`

Then in the bonus challenges you may also touch on:
* `docker-build`
* `deploy`
* `test`

Continue to the next header to already put one of these to use.


ðŸ‘©ðŸ¾â€ðŸ’» Running your Application
==============

While this is generic scaffolding, the Golang application it creates is usable and even includes basic operability needs.

To run this Golang application locally, go to the `K8s Shell` tab and enter:

```
make run
```

This command may take a few minutes, so while it is working, navigate to `main.go` in the root "demo" directory of your `Code editor` tab. In this file, look at line 64 to see where the controller application is created.

> ðŸ’¡ If you want to navigate to a specific place quickly in the code editor, you can type `ctrl+p` (`cmd+p` on macs) and put the file name there. You can even add the line number after a colon (e.g. `main.go:64`).

In the list of options passed to this `NewManager` function, you will see configuration for both a metrics and health probe endpoint. These will become visible in the output of the `make run` command.

Return to the `K8s Shell` tab and view the progress of the run command.

You should see a few commands running including prerequisites like `test` and `vet` commands, and then you should see the following four log lines:

```
INFO	controller-runtime.metrics	Metrics server is starting to listen	{"addr": ":8080"}
INFO	setup	starting manager
INFO	Starting server	{"kind": "health probe", "addr": "[::]:8081"}
INFO  Starting server	{"path": "/metrics", "kind": "metrics", "addr": "[::]:8080"}
```

While minimal for now, this is your operator and will be extended to include business logic associated with your custom application.


ðŸ’¡ Extra bonus: Understand make target prerequisites
==============

Before the server logs you will have seen other output. This was generated by the prerequisite targets for the `run` target.

The `run` target is on `Makefile:68` in the root of your `Code editor`. Here you will see the target defined as:

```
run: manifests generate fmt vet ## Run a controller from your host.
  go run ./main.go
```

In Makefiles, any names listed after a target is defined are other targets that will be run as prerequisites.

In this case, all four of the prerequisites are other targets defined in this same Makefile. To be more specific, `manifests` and `generate` both run Kubebuilder `controller-gen` commands to generate some Golang code which is then formatted and validated by `fmt` and `vet` before being executed by the originally requested `run` target.


ðŸ“• Summary
==============

While there are a few options for getting started quickly with developing controllers and operators for Kubernetes, Kubebuilder is a great choice due to its opinionated support while also providing enough flexibility to create what you need.

> ðŸ’¡ You may have noticed that Kubebuilder always uses the term "controller". Don't let this get too confusing, despite you being in a track about building an operator.
>
> Both controllers and operators are, at their core, an application running in Kubernetes that responds to changes in specified resources. The term operator is just used to indicate a specific type of controller that manages operational concerns for another application.

Since you will need an application for your core logic, Kubebuilder quickly provides an opinionated way to build, test and deploy a fit for purpose Golang application.
